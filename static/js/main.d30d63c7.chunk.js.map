{"version":3,"sources":["Graph/Sidebar.js","Algorithms/DataStructure.js","Algorithms/GraphSearch.js","Algorithms/FindCycle.js","Algorithms/Dijkstra.js","Algorithms/AStar.js","Graph/Helpers.js","Graph/Animations.js","Graph/DijkstraPopup.js","Graph/Graph.js","App.js","reportWebVitals.js","index.js"],"names":["Sidebar","props","lockUnlock","drawGraph","toggleDeleteMode","isDeleteMode","isMoveMode","toggleMoveMode","directed","weighted","toggleWeighted","toggleDirected","clearGraph","handleChangeGraphType","toggleStartAnimationNode","algorithmType","is_animation","dijkstraPopup","dijkstraPopupOpen","useState","showPanel","setShowPanel","graphTypeMenu","setGraphTypeMenu","toggleGraphTypeMenu","className","onClick","style","borderBottom","backgroundColor","indexOf","getGraphLinkedList","nodes","arrows","linked_list","forEach","node","id","arrow","startID","push","endID","weight","arrowID","nodex1","nodex2","nodey1","nodey2","depthFirstSearch","graph","visited_nodes","cur_id","last_adjacency","animations","type","i","length","neighbour","dfs","stack","unvisited_nodes","unvisited_arrows","pop","j","edge","Dijkstra","startNode","nodeList","arrowList","endNode","slice","node_weights","startNode_id","key","splice","Infinity","closest_node","closest_node_weight","closest_node_index","unvisited_node","index","edge_to_closest_node","prev_cost","cost","new_weight","getHCosts","bias","hCosts","euclidianDistance","CONTAINER_WIDTH","getOtherCosts","startNodeHCost","costs","findSmallestFCost","openSet","fCosts","smallest_node","Object","values","val","target","Math","sqrt","pow","x","y","NODE_RADIUS","findNodeFromID","filter","updateMovedNodeLinks","links","double_connections","arrow_width","keepWeights","angle","getAngle","getStartOffsets","start_offsetx","start_offsety","getEndOffsets","end_offsetx","end_offsety","doubleEdgeNodePair","sin","cos","PI","start_offsetx2","start_offsety2","end_offsetx2","end_offsety2","secondLink_replacement","replacement","x_dist","y_dist","abs","atan","end_offset","ANIMATION_SPEED_MS","SLOW_ANIMATION","animateArrow","cur_anim","edges","document","getElementById","distance","startX","startY","innerHTML","setTimeout","curX","curY","setAttribute","remove","classList","add","setNodeToVisitedWeight","weightText","setNodeUnreachable","setNodeFinal","animateTraversal","setAnimateDone","find_cycle","last_element","alert","animateDijkstra","endNodeReachable","slow_count","stopAt","DijkstraPopup","handleClose","LOCKED_MULTIPLIER","Graph","setDrawGraph","numNodes","setNumNodes","setNodes","startLineNode","setStartLineNode","numArrows","setNumArrows","setArrows","animationArrow","setAnimationArrow","deleteMode","setDeleteMode","hoverNode","setHoverNode","hoverArrow","setHoverArrow","moveMode","setMoveMode","animationNode","setAnimationNode","originalNode","setOriginalNode","setWeighted","setDirected","setAlgorithmType","animate","setAnimate","animateDone","animationStartNode","setAnimationStartNode","popupOpen","setPopupOpen","ARROW_WIDTH","handleNodeClicked","e","button","nodes_copy","sort","node1","node2","sortNodesArray","found","arrows_copy","connectNodes","breadthFirstSearch","queue","shift","graphSearch","findCycle","is_cycle","gCosts","closedSet","prevNode","current_node_obj","current_node","prev_node","gCost","keys","AStar","animateAStar","handleMouseUp","connecting_arrows","overlap","arrow1","numLinks","handleElementHover","baseVal","handleLinkClick","link","connectedNodes","i_paired_link","handleMoveNodeInterrupt","temp","togglePopup","handleGraphReset","height","width","onMouseDown","nativeEvent","offsetX","offsetY","coord_x","coord_y","update","idx","includes","onMouseMove","pointer_coords","pointer_size","pointerx","pointery","startx","starty","endx","endy","markerWidth","markerHeight","refX","refY","orient","d","fill","map","x1","y1","x2","y2","onMouseEnter","onMouseLeave","min","max","step","value","onChange","substr","eventNum","parseInt","addedValue","data","prevValue","floor","MAX","String","updateArrowWeight","undefined","color","r","cx","cy","onMouseUp","textAnchor","stroke","strokeWidth","alignmentBaseline","new_arrows","include","window","confirm","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d30d63c7.chunk.js","sourcesContent":["import \"./Sidebar.css\";\nimport React, { useState } from \"react\";\n\nexport function Sidebar(props) {\n\tconst {\n\t\tlockUnlock,\n\t\tdrawGraph,\n\t\ttoggleDeleteMode,\n\t\tisDeleteMode,\n\t\tisMoveMode,\n\t\ttoggleMoveMode,\n\t\tdirected,\n\t\tweighted,\n\t\ttoggleWeighted,\n\t\ttoggleDirected,\n\t\tclearGraph,\n\t\thandleChangeGraphType,\n\t\ttoggleStartAnimationNode,\n\t\talgorithmType,\n\t\tis_animation,\n\t\tdijkstraPopup,\n\t\tdijkstraPopupOpen,\n\t} = props;\n\n\tconst [showPanel, setShowPanel] = useState(true);\n\tconst [graphTypeMenu, setGraphTypeMenu] = useState(false);\n\n\tconst toggleSidebar = () => {\n\t\tsetShowPanel(!showPanel);\n\t};\n\n\tconst toggleGraphTypeMenu = () => {\n\t\tsetGraphTypeMenu(!graphTypeMenu);\n\t\thandleChangeGraphType();\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<div className={`sidebar ${showPanel ? \"open-panel\" : \"close-panel\"}`}>\n\t\t\t\t<div>\n\t\t\t\t\t<div className=\"panel panel-default\">\n\t\t\t\t\t\t<p\n\t\t\t\t\t\t\tclassName={`panel-element ${\n\t\t\t\t\t\t\t\tis_animation ? \"panel-unclickable\" : \"\"\n\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\tonClick={graphTypeMenu ? toggleGraphTypeMenu : lockUnlock}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`panel-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"panel-item-open\" : \"panel-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{drawGraph ? \"Lock\" : \"Unlock\"}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`dropdown-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"dropdown-item-open\" : \"dropdown-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\tstyle={{ borderBottom: \"2px solid white\" }}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{\"<<\"}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p\n\t\t\t\t\t\t\tclassName={`panel-element ${\n\t\t\t\t\t\t\t\tis_animation\n\t\t\t\t\t\t\t\t\t? \"panel-unclickable\"\n\t\t\t\t\t\t\t\t\t: graphTypeMenu && !weighted\n\t\t\t\t\t\t\t\t\t? \"graphTypeSelected\"\n\t\t\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\tonClick={\n\t\t\t\t\t\t\t\tgraphTypeMenu\n\t\t\t\t\t\t\t\t\t? () => toggleWeighted(false)\n\t\t\t\t\t\t\t\t\t: drawGraph\n\t\t\t\t\t\t\t\t\t? toggleGraphTypeMenu\n\t\t\t\t\t\t\t\t\t: () => toggleStartAnimationNode(\"depth-first-search\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\talgorithmType === \"depth-first-search\"\n\t\t\t\t\t\t\t\t\t? { backgroundColor: \"green\" }\n\t\t\t\t\t\t\t\t\t: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`panel-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"panel-item-open\" : \"panel-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{drawGraph ? \"Change Graph Type\" : \"Depth-First Search\"}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`dropdown-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"dropdown-item-open\" : \"dropdown-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tUnweighted\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p\n\t\t\t\t\t\t\tclassName={`panel-element ${\n\t\t\t\t\t\t\t\tis_animation\n\t\t\t\t\t\t\t\t\t? \"panel-unclickable\"\n\t\t\t\t\t\t\t\t\t: graphTypeMenu && weighted\n\t\t\t\t\t\t\t\t\t? \"graphTypeSelected\"\n\t\t\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\tonClick={\n\t\t\t\t\t\t\t\tgraphTypeMenu\n\t\t\t\t\t\t\t\t\t? () => toggleWeighted(true)\n\t\t\t\t\t\t\t\t\t: drawGraph\n\t\t\t\t\t\t\t\t\t? toggleMoveMode\n\t\t\t\t\t\t\t\t\t: () => toggleStartAnimationNode(\"breadth-first-search\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\tgraphTypeMenu\n\t\t\t\t\t\t\t\t\t? {}\n\t\t\t\t\t\t\t\t\t: isMoveMode || algorithmType === \"breadth-first-search\"\n\t\t\t\t\t\t\t\t\t? { backgroundColor: \"green\" }\n\t\t\t\t\t\t\t\t\t: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`panel-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"panel-item-open\" : \"panel-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{drawGraph ? \"Move Node\" : \"Breadth-First Search\"}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`dropdown-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"dropdown-item-open\" : \"dropdown-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tWeighted\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p\n\t\t\t\t\t\t\tclassName={`panel-element ${\n\t\t\t\t\t\t\t\tis_animation\n\t\t\t\t\t\t\t\t\t? \"panel-unclickable\"\n\t\t\t\t\t\t\t\t\t: graphTypeMenu && !directed\n\t\t\t\t\t\t\t\t\t? \"graphTypeSelected\"\n\t\t\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\tonClick={\n\t\t\t\t\t\t\t\tgraphTypeMenu\n\t\t\t\t\t\t\t\t\t? () => toggleDirected(false)\n\t\t\t\t\t\t\t\t\t: drawGraph\n\t\t\t\t\t\t\t\t\t? toggleDeleteMode\n\t\t\t\t\t\t\t\t\t: dijkstraPopup\n\t\t\t\t\t\t\t} //toggleStartAnimationNode(\"dijkstra\")\n\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\tgraphTypeMenu\n\t\t\t\t\t\t\t\t\t? {}\n\t\t\t\t\t\t\t\t\t: isDeleteMode ||\n\t\t\t\t\t\t\t\t\t  dijkstraPopupOpen ||\n\t\t\t\t\t\t\t\t\t  algorithmType.indexOf(\"dijkstra\") !== -1\n\t\t\t\t\t\t\t\t\t? { backgroundColor: \"green\" }\n\t\t\t\t\t\t\t\t\t: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`panel-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"panel-item-open\" : \"panel-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{drawGraph ? \"Delete Node/Link\" : \"Dijkstra\"}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`dropdown-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"dropdown-item-open\" : \"dropdown-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tUndirected\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p\n\t\t\t\t\t\t\tclassName={`panel-element ${\n\t\t\t\t\t\t\t\tis_animation\n\t\t\t\t\t\t\t\t\t? \"panel-unclickable\"\n\t\t\t\t\t\t\t\t\t: graphTypeMenu && directed\n\t\t\t\t\t\t\t\t\t? \"graphTypeSelected\"\n\t\t\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\tonClick={\n\t\t\t\t\t\t\t\tgraphTypeMenu\n\t\t\t\t\t\t\t\t\t? () => toggleDirected(true)\n\t\t\t\t\t\t\t\t\t: drawGraph\n\t\t\t\t\t\t\t\t\t? clearGraph\n\t\t\t\t\t\t\t\t\t: () => toggleStartAnimationNode(\"A*\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\tgraphTypeMenu\n\t\t\t\t\t\t\t\t\t? {}\n\t\t\t\t\t\t\t\t\t: !drawGraph && algorithmType === \"A*\"\n\t\t\t\t\t\t\t\t\t? { backgroundColor: \"green\" }\n\t\t\t\t\t\t\t\t\t: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`panel-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"panel-item-open\" : \"panel-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{drawGraph ? \"Clear Graph\" : \"A*\"}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={`dropdown-item ${\n\t\t\t\t\t\t\t\t\tgraphTypeMenu ? \"dropdown-item-open\" : \"dropdown-item-close\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tDirected\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t{!drawGraph && (\n\t\t\t\t\t\t\t<p\n\t\t\t\t\t\t\t\tclassName={`panel-element ${\n\t\t\t\t\t\t\t\t\tis_animation ? \"panel-unclickable\" : \"\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\tonClick={() => toggleStartAnimationNode(\"find-cycle\")}\n\t\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\t\talgorithmType === \"find-cycle\"\n\t\t\t\t\t\t\t\t\t\t? { backgroundColor: \"green\" }\n\t\t\t\t\t\t\t\t\t\t: {}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<span className={\"panel-item\"}>Find Cycle</span>\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div className=\"panel-hide\" onClick={toggleSidebar}>\n\t\t\t\t<div\n\t\t\t\t\tclassName={`close-open ${showPanel ? \"open-rotate\" : \"close-rotate\"}`}\n\t\t\t\t>\n\t\t\t\t\t{showPanel ? \">\" : \"<\"}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n","//Returns a linked list data structure to represent the nodes and edges\nexport const getGraphLinkedList = (nodes, arrows, directed = true) => {\n\tconst linked_list = {}; //Initialize linked list data structure\n\n\t//Initialize empty array for each nodes linked list\n\tnodes.forEach((node) => {\n\t\tlinked_list[node.id] = [];\n\t});\n\n\t//Add the edges to the corresponding node\n\tarrows.forEach((arrow) => {\n\t\t//Keep track of the start and end coords of the arrows for animation\n\t\tlinked_list[arrow.startID].push({\n\t\t\tendID: arrow.endID,\n\t\t\tweight: arrow.weight,\n\t\t\tarrowID: arrow.id,\n\t\t\tnodex1: arrow.nodex1,\n\t\t\tnodex2: arrow.nodex2,\n\t\t\tnodey1: arrow.nodey1,\n\t\t\tnodey2: arrow.nodey2,\n\t\t});\n\t\tif (!directed) {\n\t\t\t//Switch x1,x2 and y1,y2 for undirected arrow\n\t\t\tlinked_list[arrow.endID].push({\n\t\t\t\tendID: arrow.startID,\n\t\t\t\tweight: arrow.weight,\n\t\t\t\tarrowID: arrow.id,\n\t\t\t\tnodex1: arrow.nodex2,\n\t\t\t\tnodex2: arrow.nodex1,\n\t\t\t\tnodey1: arrow.nodey2,\n\t\t\t\tnodey2: arrow.nodey1,\n\t\t\t});\n\t\t}\n\t});\n\n\treturn linked_list;\n};\n","import { getGraphLinkedList } from \"./DataStructure\";\n\n//Returns list of visited nodes and arrows in the order they were visited\nexport const graphSearch = (\n\tstartNode,\n\tnodeList,\n\tarrowList,\n\tdirected,\n\tbreadthFirstSearch = true\n) => {\n\tconst graph = getGraphLinkedList(nodeList, arrowList, directed);\n\n\tconst visited_nodes = {}; //Dictionary used to give better performance (visited_nodes[cur.id] = 1) for checking if node is visited\n\t//const visited_order = []; //Need to use list to get the visited_nodes order\n\tconst queue = [startNode.id];\n\tvisited_nodes[startNode.id] = true;\n\tconst animations = []; //Animations for both arrows and nodes <-- [{type:arrow/node, stage:seen/visited,id:ID}, ...]\n\n\tif (breadthFirstSearch) {\n\t\tanimations.push({ type: \"node\", id: startNode.id });\n\t\tdo {\n\t\t\t//Get current node id\n\t\t\tconst cur_id = queue.shift();\n\n\t\t\tfor (let i = 0; i < graph[cur_id].length; ++i) {\n\t\t\t\t//Add queue nodes to list\n\t\t\t\tconst neighbour = graph[cur_id][i].endID;\n\t\t\t\tif (!visited_nodes[neighbour]) {\n\t\t\t\t\tqueue.push(neighbour);\n\t\t\t\t\tconst last_adjacency = graph[cur_id][i];\n\t\t\t\t\tanimations.push({\n\t\t\t\t\t\ttype: \"arrow\",\n\t\t\t\t\t\tid: last_adjacency.arrowID,\n\t\t\t\t\t\tnodex1: last_adjacency.nodex1,\n\t\t\t\t\t\tnodex2: last_adjacency.nodex2,\n\t\t\t\t\t\tnodey1: last_adjacency.nodey1,\n\t\t\t\t\t\tnodey2: last_adjacency.nodey2,\n\t\t\t\t\t});\n\t\t\t\t\tanimations.push({ type: \"node\", id: neighbour });\n\t\t\t\t\t//visited_order.push(cur_id);\n\t\t\t\t\tvisited_nodes[neighbour] = true; //push id of neighbour to visited_nodes and add animation\n\t\t\t\t}\n\t\t\t}\n\t\t} while (queue.length);\n\t} else {\n\t\tdepthFirstSearch(graph, visited_nodes, startNode.id, null, animations);\n\t}\n\n\treturn animations;\n};\n\nconst depthFirstSearch = (\n\tgraph,\n\tvisited_nodes,\n\tcur_id,\n\tlast_adjacency,\n\tanimations\n) => {\n\t//push arrow pointing from previous node into animations\n\tif (last_adjacency && !visited_nodes[last_adjacency.endID]) {\n\t\tanimations.push({\n\t\t\ttype: \"arrow\",\n\t\t\tid: last_adjacency.arrowID,\n\t\t\tnodex1: last_adjacency.nodex1,\n\t\t\tnodex2: last_adjacency.nodex2,\n\t\t\tnodey1: last_adjacency.nodey1,\n\t\t\tnodey2: last_adjacency.nodey2,\n\t\t});\n\t}\n\n\tanimations.push({ type: \"node\", id: cur_id });\n\t//visited_order.push(cur_id);\n\tvisited_nodes[cur_id] = true; //push id of current node to visited_nodes and add animation\n\n\tfor (let i = 0; i < graph[cur_id].length; ++i) {\n\t\tconst neighbour = graph[cur_id][i].endID;\n\t\tif (!visited_nodes[neighbour]) {\n\t\t\tdepthFirstSearch(\n\t\t\t\tgraph,\n\t\t\t\tvisited_nodes,\n\t\t\t\tneighbour,\n\t\t\t\tgraph[cur_id][i],\n\t\t\t\tanimations\n\t\t\t);\n\t\t}\n\t}\n};\n","import { getGraphLinkedList } from \"./DataStructure\";\n\n//Returns true if there is at least one cycle in the graph\nexport const findCycle = (startNode, nodeList, arrowList, directed) => {\n\tconst graph = getGraphLinkedList(nodeList, arrowList, directed);\n\n\tconst visited_nodes = {}; //Dictionary used to give better performance (visited_nodes[cur.id] = 1) for checking if node is visited\n\tconst stack = {}; //Used to keep track of nodes visited during depth first search from reference node\n\tconst unvisited_nodes = [startNode.id];\n\tconst unvisited_arrows = [];\n\tconst animations = []; //Animations for both arrows and nodes <-- [{type:arrow/node, stage:seen/visited,id:ID}, ...]\n\n\tdo {\n\t\tif (\n\t\t\tdfs(\n\t\t\t\tgraph,\n\t\t\t\tstack,\n\t\t\t\tvisited_nodes,\n\t\t\t\tunvisited_nodes,\n\t\t\t\tunvisited_arrows,\n\t\t\t\tdirected,\n\t\t\t\tanimations\n\t\t\t)\n\t\t) {\n\t\t\treturn [true, animations];\n\t\t}\n\t} while (unvisited_nodes.length);\n\n\treturn [false, animations];\n};\n\n//depth first search from reference node (top of unvisted_nodes stack)\nconst dfs = (\n\tgraph,\n\tstack,\n\tvisited_nodes,\n\tunvisited_nodes,\n\tunvisited_arrows,\n\tdirected,\n\tanimations\n) => {\n\t//Get current node id\n\tconst cur_id = unvisited_nodes.pop(); //depth-first search\n\tconst last_adjacency = unvisited_arrows.length\n\t\t? unvisited_arrows.pop()\n\t\t: null;\n\n\t//push arrow pointing from previous node into animations\n\tif (last_adjacency && !visited_nodes[last_adjacency.endID]) {\n\t\tanimations.push({\n\t\t\ttype: \"arrow\",\n\t\t\tid: last_adjacency.arrowID,\n\t\t\tnodex1: last_adjacency.nodex1,\n\t\t\tnodex2: last_adjacency.nodex2,\n\t\t\tnodey1: last_adjacency.nodey1,\n\t\t\tnodey2: last_adjacency.nodey2,\n\t\t});\n\t}\n\n\tanimations.push({ type: \"node\", id: cur_id });\n\tvisited_nodes[cur_id] = true;\n\tstack[cur_id] = true;\n\n\tfor (let i = 0; i < graph[cur_id].length; ++i) {\n\t\t//Add unvisited nodes to list\n\t\tconst neighbour = graph[cur_id][i].endID;\n\t\tif (!visited_nodes[neighbour]) {\n\t\t\tunvisited_nodes.push(neighbour);\n\t\t\tunvisited_arrows.push(graph[cur_id][i]);\n\t\t\tif (\n\t\t\t\tdfs(\n\t\t\t\t\tgraph,\n\t\t\t\t\tstack,\n\t\t\t\t\tvisited_nodes,\n\t\t\t\t\tunvisited_nodes,\n\t\t\t\t\tunvisited_arrows,\n\t\t\t\t\tdirected,\n\t\t\t\t\tanimations\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t//Node seen was already visited, check if it is in the stack (in the same iteration of dfs) or if it is undirected and arrow id is not the same as last connection\n\t\telse if (\n\t\t\t(directed && stack[neighbour]) ||\n\t\t\t(!directed && graph[cur_id][i].arrowID !== last_adjacency.arrowID)\n\t\t) {\n\t\t\tfor (let j = 0; j < graph[neighbour].length; ++j) {\n\t\t\t\tconst edge_neighbour = graph[neighbour][j];\n\t\t\t\tif (visited_nodes[edge_neighbour.endID]) {\n\t\t\t\t\t//Animate arrow\n\t\t\t\t\tconst edge = graph[cur_id][i];\n\t\t\t\t\tanimations.push({\n\t\t\t\t\t\ttype: \"arrow\",\n\t\t\t\t\t\tid: edge.arrowID,\n\t\t\t\t\t\tnodex1: edge.nodex1,\n\t\t\t\t\t\tnodex2: edge.nodex2,\n\t\t\t\t\t\tnodey1: edge.nodey1,\n\t\t\t\t\t\tnodey2: edge.nodey2,\n\t\t\t\t\t});\n\t\t\t\t\t//Animate node (special animation)\n\t\t\t\t\tanimations.push({ type: \"node\", id: edge.endID });\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete stack[cur_id];\n\treturn false;\n};\n","import { getGraphLinkedList } from \"./DataStructure\";\n\n//Returns weights and animations of graph traversal using Dijkstra's Algorithm\nexport const Dijkstra = (\n\tstartNode,\n\tnodeList,\n\tarrowList,\n\tdirected,\n\tendNode = null\n) => {\n\tconst graph = getGraphLinkedList(nodeList, arrowList, directed);\n\n\tconst visited_nodes = [];\n\tconst unvisited_nodes = nodeList.slice();\n\tconst animations = []; //Animations for both arrows and nodes\n\tconst node_weights = {}; //dictionary of {id:weight, ...} pairs\n\tconst startNode_id = startNode.id;\n\tvisited_nodes.push(startNode);\n\tunvisited_nodes.splice(startNode_id - 1, 1);\n\n\tgraph[startNode_id].forEach((edge) => {\n\t\tnode_weights[edge.endID] = edge.weight;\n\t});\n\n\tfor (const key in graph) {\n\t\tif (!node_weights[key]) {\n\t\t\tnode_weights[key] = Infinity;\n\t\t}\n\t}\n\tnode_weights[startNode_id] = 0;\n\tanimations.push({ type: \"node\", id: startNode_id });\n\n\tdo {\n\t\tlet closest_node = null;\n\t\tlet closest_node_weight = Infinity;\n\t\tlet closest_node_index = -1;\n\t\tunvisited_nodes.forEach((unvisited_node, index) => {\n\t\t\tif (node_weights[unvisited_node.id] < closest_node_weight) {\n\t\t\t\tclosest_node = unvisited_node;\n\t\t\t\tclosest_node_weight = node_weights[unvisited_node.id];\n\t\t\t\tclosest_node_index = index;\n\t\t\t}\n\t\t});\n\t\tif (closest_node) {\n\t\t\t//Find the visited node that connects to current closest node (with the lowest cost)\n\t\t\tlet edge_to_closest_node = graph[visited_nodes[0].id][0];\n\t\t\tlet prev_cost = Infinity;\n\t\t\tvisited_nodes.forEach((node) => {\n\t\t\t\tgraph[node.id].forEach((edge) => {\n\t\t\t\t\tconst cost = node_weights[node.id] + edge.weight;\n\t\t\t\t\tif (edge.endID === closest_node.id && cost < prev_cost) {\n\t\t\t\t\t\tprev_cost = cost;\n\t\t\t\t\t\tedge_to_closest_node = edge;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tanimations.push({\n\t\t\t\ttype: \"arrow\",\n\t\t\t\tid: edge_to_closest_node.arrowID,\n\t\t\t\tnodex1: edge_to_closest_node.nodex1,\n\t\t\t\tnodex2: edge_to_closest_node.nodex2,\n\t\t\t\tnodey1: edge_to_closest_node.nodey1,\n\t\t\t\tnodey2: edge_to_closest_node.nodey2,\n\t\t\t});\n\t\t\tanimations.push({ type: \"node\", id: closest_node.id });\n\n\t\t\tif (endNode && endNode.id === closest_node.id) {\n\t\t\t\treturn [node_weights, animations];\n\t\t\t}\n\n\t\t\t//Move closest node from unvisited to visited\n\t\t\tunvisited_nodes.splice(closest_node_index, 1);\n\t\t\tvisited_nodes.push(closest_node);\n\n\t\t\t//Update graph weights based on new closest node\n\t\t\tgraph[closest_node.id].forEach((edge) => {\n\t\t\t\tconst new_weight = closest_node_weight + edge.weight;\n\t\t\t\tif (new_weight < node_weights[edge.endID]) {\n\t\t\t\t\tnode_weights[edge.endID] = new_weight;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tclosest_node = unvisited_nodes.splice(0, 1)[0];\n\t\t\t\tvisited_nodes.push(closest_node);\n\t\t\t\tanimations.push({ type: \"node\", id: closest_node.id });\n\t\t\t} while (unvisited_nodes.length);\n\t\t}\n\t} while (unvisited_nodes.length); //|| closest_node.id === endNode.id (<- just add that to stop at end node for non-negative weights)\n\n\tif (endNode !== null) {\n\t\tanimations.push({ type: \"node\", id: endNode.id });\n\t}\n\n\treturn [node_weights, animations];\n};\n","import { getGraphLinkedList } from \"./DataStructure\";\nimport { CONTAINER_WIDTH } from \"../Graph/Graph\";\n\n//Returns weights and animations of graph traversal using A* Algorithm (requires defined start and end nodes)\n//Hcost is defined as the straight line distance between two nodes with a scale factor to not overpower the weight (euclidian)\n\n/*\nA* is a good general purpose path-finding algorithm for finding a good path between the start and end nodes, but it does not guarantee the shortest path unless both the situation and heuristic are favourable\n\nFor example, traversal in a 2D grid is well suited to A* since a step between any two spaces on the grid has the same weight, and the heuristic is meaningful to follow\nOther situations, such as doing graph traversals can still provide good solutions but are less suited for finding the optimal path because the heuristics are less reliable\n\nEx: Scheduling a flight from Calgary to Toronto, where two possible flights leave at the same time\nA) There is a 1 hour flight to Vancouver with a 1 hour overlay, and then a 6 hour flight to Toronto (8 hours total)\nB) There is a 2 hour flight to Winnipeg with a 4 hour overlay, and then a 3 hour flight to Toronto (9 hours total)\n\nDijkstra would say option B is preferred because it takes the least amount of time to get to Toronto\nBased on the heuristic and its weight on the fCost, A* would likely choose option A because Vancouver is in the wrong direction and the trip through Winnipeg would likely be selected\nAlthough in this situation A* didn't provide the optimal path, as you add more and more flights it will be able to select a flight with a \"good enough result\" in much less computational cost than it would take Dijkstra to find the \"best result\"\nIf the layover in Winnipeg was 12 hours instead of 4, A* would be able to identify that going through Winnipeg does not make sense, and would also select the flight through Vancouver\n\nA thought to overcome this and guarantee the shortest path would be as follows:\nOnce you have reached the end node, check the openset to see if there are any nodes with a lower gcost and follow them until either their gcost exceeds the gcost to reach the endnode, or the endnode is reached\nThis is just Dijkstra's algorithm though...\n\nSources:\nhttp://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html \nhttp://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html \nhttps://en.wikipedia.org/wiki/A*_search_algorithm\n*/\n\nexport const AStar = (\n\tstartNode,\n\tendNode,\n\tnodeList,\n\tarrowList,\n\tdirected,\n\tweighted = false\n) => {\n\tconst graph = getGraphLinkedList(nodeList, arrowList, directed);\n\tconst startID = startNode.id;\n\tconst animations = [];\n\n\t//Get hcosts\n\tconst gCosts = getOtherCosts(startNode, nodeList); //minimum cost from start node to current node\n\tconst hCosts = getHCosts(endNode, nodeList, weighted); //(heuristic cost) estimated cost to the end from the current node\n\tconst fCosts = getOtherCosts(startNode, nodeList, hCosts[startID]); //sum of gcost and hcost\n\tconst closedSet = {}; //visited nodes\n\tconst openSet = {}; //reached but not yet visited nodes\n\topenSet[startID] = { node: startNode, prevNode: null };\n\n\t//Loop while openset still has values (and endnode has not been reached)\n\tdo {\n\t\tconst current_node_obj = findSmallestFCost(openSet, fCosts);\n\t\tconst current_node = current_node_obj.node;\n\t\tconst prev_node = current_node_obj.prevNode;\n\t\tclosedSet[current_node.id] = true;\n\t\tdelete openSet[current_node.id];\n\n\t\t//Find the visited node that connects to current closest node\n\t\tif (prev_node) {\n\t\t\tgraph[prev_node.id].forEach((edge) => {\n\t\t\t\tif (edge.endID === current_node.id) {\n\t\t\t\t\tanimations.push({\n\t\t\t\t\t\ttype: \"arrow\",\n\t\t\t\t\t\tid: edge.arrowID,\n\t\t\t\t\t\tnodex1: edge.nodex1,\n\t\t\t\t\t\tnodex2: edge.nodex2,\n\t\t\t\t\t\tnodey1: edge.nodey1,\n\t\t\t\t\t\tnodey2: edge.nodey2,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tanimations.push({ type: \"node\", id: current_node.id });\n\n\t\tif (current_node.id === endNode.id) {\n\t\t\t//Get the animations for going from start to end node\n\t\t\treturn [animations, gCosts, true];\n\t\t}\n\n\t\t//Check the neighbours of the current node\n\t\tgraph[current_node.id].forEach((edge) => {\n\t\t\tconst gCost = gCosts[current_node.id] + edge.weight;\n\t\t\tif (!closedSet[edge.endID] && gCost < gCosts[edge.endID]) {\n\t\t\t\tgCosts[edge.endID] = gCost;\n\t\t\t\tfCosts[edge.endID] = gCost + edge.weight * hCosts[edge.endID]; // Bigger weights will have their hCosts scaled more\n\t\t\t\topenSet[edge.endID] = {\n\t\t\t\t\tnode: nodeList[edge.endID - 1],\n\t\t\t\t\tprevNode: current_node,\n\t\t\t\t}; //If node already in openset, just override it\n\t\t\t}\n\t\t});\n\t} while (Object.keys(openSet).length !== 0);\n\n\tanimations.push({ type: \"node\", id: endNode.id });\n\treturn [animations, gCosts, false];\n};\n\n//Gets hCosts of each node relative to end node (absolute distance) -- scaled based on width of canvas so that it more likely underestimates the actual cost (better accuracy, less performacne)\nconst getHCosts = (endNode, nodes, weighted) => {\n\tconst bias = weighted ? 8 : 4; //Aribitray value to scale hCost (larger values will be faster and less optimal)\n\tconst hCosts = {};\n\tfor (let id = 1; id <= nodes.length; ++id) {\n\t\thCosts[id] =\n\t\t\t(euclidianDistance(endNode, nodes[id - 1]) / CONTAINER_WIDTH) * bias; //the node with id is the (id-1)th index of nodes\n\t}\n\treturn hCosts;\n};\n\n//Used to get initial g and f costs of each node relative (infinity)\nconst getOtherCosts = (startNode, nodes, startNodeHCost = null) => {\n\tconst costs = {};\n\tfor (let id = 1; id <= nodes.length; ++id) {\n\t\tif (id === startNode.id && startNodeHCost) {\n\t\t\tcosts[id] = startNodeHCost;\n\t\t} else if (id === startNode.id) {\n\t\t\tcosts[id] = 0;\n\t\t} else {\n\t\t\tcosts[id] = Infinity;\n\t\t}\n\t}\n\n\treturn costs;\n};\n\nconst findSmallestFCost = (openSet, fCosts) => {\n\tlet smallest_node = Object.values(openSet)[0];\n\n\tfor (const val of Object.values(openSet)) {\n\t\tif (fCosts[val.node.id] < fCosts[smallest_node.node.id]) {\n\t\t\tsmallest_node = val;\n\t\t}\n\t}\n\n\treturn smallest_node;\n};\n\n// const manhattanDistance = (node, target) => {\n//     return Math.abs(node.x-target.x) + Math.abs(node.y-target.y);\n// }\n\nconst euclidianDistance = (node, target) => {\n\treturn Math.sqrt(\n\t\tMath.pow(node.x - target.x, 2) + Math.pow(node.y - target.y, 2)\n\t);\n};\n","export const NODE_RADIUS = 20;\n\n//Sorts Node Array\nexport const sortNodesArray = (nodes) => {\n\tconst nodes_copy = nodes.sort((node1, node2) => node1.id - node2.id);\n\treturn nodes_copy;\n};\n\n//Returns node object from nodes array based on unique id\nexport const findNodeFromID = (id, nodes) => {\n\tconst valid_nodes = nodes.filter((node) => {\n\t\treturn node.id === id;\n\t});\n\treturn valid_nodes[0];\n};\n\n//Updates arrows to new node location\nexport const updateMovedNodeLinks = (\n\tstartNode,\n\tendNode,\n\tindex,\n\tlinks,\n\tdouble_connections,\n\tarrow_width,\n\tdirected = true,\n\tkeepWeights = true\n) => {\n\tconst angle = getAngle(startNode, endNode);\n\t//const arrow_width = 11; //px\n\tlet [start_offsetx, start_offsety] = getStartOffsets(startNode, angle);\n\tlet [end_offsetx, end_offsety] = getEndOffsets(endNode, angle, directed);\n\n\tlet doubleEdgeNodePair = -1; //Look for two nodes connected by two directional edges\n\tif (directed) {\n\t\tfor (let i = index; i < links.length; ++i) {\n\t\t\tif (startNode.id === links[i].endID && endNode.id === links[i].startID) {\n\t\t\t\t//Mark index of double connected nodes\n\t\t\t\tdoubleEdgeNodePair = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (doubleEdgeNodePair >= 0) {\n\t\t//Calculate required offset adjustmenet for doubly connected nodes\n\t\tstart_offsetx += arrow_width * Math.sin(angle);\n\t\tstart_offsety += arrow_width * Math.cos(angle);\n\t\tend_offsetx += arrow_width * Math.sin(angle);\n\t\tend_offsety += arrow_width * Math.cos(angle);\n\n\t\t//Reverse arrow has backwards startNode and EndNode\n\t\tconst [start_offsetx2, start_offsety2] = getStartOffsets(\n\t\t\tendNode,\n\t\t\tangle + Math.PI\n\t\t);\n\t\tconst [end_offsetx2, end_offsety2] = getEndOffsets(\n\t\t\tstartNode,\n\t\t\tangle + Math.PI\n\t\t);\n\n\t\tconst secondLink_replacement = {\n\t\t\tnodex1: start_offsetx2 - arrow_width * Math.sin(angle),\n\t\t\tnodey1: start_offsety2 - arrow_width * Math.cos(angle),\n\t\t\tnodex2: end_offsetx2 - arrow_width * Math.sin(angle),\n\t\t\tnodey2: end_offsety2 - arrow_width * Math.cos(angle),\n\t\t\tstartID: links[doubleEdgeNodePair].startID,\n\t\t\tendID: links[doubleEdgeNodePair].endID,\n\t\t\tid: links[doubleEdgeNodePair].id,\n\t\t\tweight: keepWeights ? links[doubleEdgeNodePair].weight : 1,\n\t\t};\n\t\tlinks.splice(doubleEdgeNodePair, 1, secondLink_replacement); //Replace current line by updated offset\n\t\tdouble_connections.push(secondLink_replacement.id);\n\t}\n\tconst replacement = {\n\t\tnodex1: start_offsetx,\n\t\tnodey1: start_offsety,\n\t\tnodex2: end_offsetx,\n\t\tnodey2: end_offsety,\n\t\tstartID: links[index].startID,\n\t\tendID: links[index].endID,\n\t\tid: links[index].id,\n\t\tweight: keepWeights ? links[index].weight : 1,\n\t};\n\tlinks.splice(index, 1, replacement);\n};\n\n//Get angle between nodes (radians)\nexport const getAngle = (startNode, endNode) => {\n\tconst x_dist = endNode.x - startNode.x;\n\tconst y_dist = -1 * (endNode.y - startNode.y); //Vertical distance measured from top = 0 so multiply by -1 to get y positive wrt bottom of canvas\n\tconst angle_ref =\n\t\tx_dist !== 0 ? Math.abs(Math.atan(y_dist / x_dist)) : Math.PI / 2; //reference angle\n\n\t//Standard angle\n\tlet angle = angle_ref;\n\tif (y_dist >= 0 && x_dist < 0) {\n\t\tangle = Math.PI - angle;\n\t} else if (y_dist < 0) {\n\t\tif (x_dist > 0) {\n\t\t\tangle = 2 * Math.PI - angle;\n\t\t} else {\n\t\t\tangle = Math.PI + angle;\n\t\t}\n\t}\n\treturn angle;\n};\n\n//Offset of x,y wrt center of starting node\nexport const getStartOffsets = (startNode, angle) => {\n\tconst start_offset = NODE_RADIUS + 1;\n\tconst start_offsetx = startNode.x + start_offset * Math.cos(angle);\n\tconst start_offsety = startNode.y - start_offset * Math.sin(angle);\n\treturn [start_offsetx, start_offsety];\n};\n\n//Offset x,y wrt center of end node\nexport const getEndOffsets = (node, angle, directed = true) => {\n\tconst end_offset = directed ? NODE_RADIUS + 15 : NODE_RADIUS + 1;\n\tconst end_offsetx = node.x - end_offset * Math.cos(angle);\n\tconst end_offsety = node.y + end_offset * Math.sin(angle);\n\treturn [end_offsetx, end_offsety];\n};\n","import \"./Animations.css\";\nimport { getAngle } from \"./Helpers\";\nexport const ANIMATION_SPEED_MS = 600; //ms\nconst STEP_SIZE = 5; //ms\nconst SLOW_ANIMATION = 250;\n\nconst animateArrow = (cur_anim, i) => {\n\tconst edges = document.getElementById(\"animation-edges\"); //Get all edges\n\tconst increment = ANIMATION_SPEED_MS / STEP_SIZE;\n\n\tconst distance = Math.sqrt(\n\t\tMath.pow(cur_anim.nodex1 - cur_anim.nodex2, 2) +\n\t\t\tMath.pow(cur_anim.nodey1 - cur_anim.nodey2, 2)\n\t);\n\tconst angle = getAngle(\n\t\t{ x: cur_anim.nodex1, y: cur_anim.nodey1 },\n\t\t{ x: cur_anim.nodex2, y: cur_anim.nodey2 }\n\t);\n\tconst startX = cur_anim.nodex1;\n\tconst startY = cur_anim.nodey1;\n\t//Initialize entire animated arrow at start\n\tedges.innerHTML += `<line id=\"temp-${cur_anim.id}-visited\" x1=${startX} y1=${startY} x2=${startX} y2=${startY} class=\"arrow-visited-animate\" ></line>`;\n\n\t//Slowly increase length until arrow reaches end coordinates\n\tfor (let j = 0; j < increment; ++j) {\n\t\tsetTimeout(() => {\n\t\t\tconst curX = startX + (j / increment) * distance * Math.cos(angle);\n\t\t\tconst curY = startY - (j / increment) * distance * Math.sin(angle);\n\t\t\tdocument\n\t\t\t\t.getElementById(`temp-${cur_anim.id}-visited`)\n\t\t\t\t.setAttribute(\"x2\", `${curX}`);\n\t\t\tdocument\n\t\t\t\t.getElementById(`temp-${cur_anim.id}-visited`)\n\t\t\t\t.setAttribute(\"y2\", `${curY}`);\n\t\t}, i * ANIMATION_SPEED_MS + j * STEP_SIZE); //Go until i+1\n\t}\n\n\t//Remove temporary arrow and add style to animated arrow\n\tsetTimeout(() => {\n\t\tdocument.getElementById(`temp-${cur_anim.id}-visited`).remove();\n\t\tdocument\n\t\t\t.getElementById(`arrow-${cur_anim.id}`)\n\t\t\t.classList.add(\"arrow-visited\");\n\t}, (i + 1) * ANIMATION_SPEED_MS);\n};\n\nconst setNodeToVisitedWeight = (node_weights, animations, i) => {\n\tdocument\n\t\t.getElementById(`node-${animations[i].id}`)\n\t\t.classList.add(\"node-visited\");\n\tdocument\n\t\t.getElementById(`node-text-${animations[i].id}`)\n\t\t.classList.add(\"node-text-visited\");\n\tconst weightText = document.getElementById(`node-weight-${animations[i].id}`);\n\tweightText.classList.add(\"node-weight-visited\");\n\tweightText.innerHTML =\n\t\tnode_weights[animations[i].id] === 0\n\t\t\t? \"Start\"\n\t\t\t: node_weights[animations[i].id];\n};\n\nconst setNodeUnreachable = (animations, i) => {\n\tdocument\n\t\t.getElementById(`node-${animations[i].id}`)\n\t\t.classList.add(\"node-unreachable\");\n\tdocument\n\t\t.getElementById(`node-text-${animations[i].id}`)\n\t\t.classList.add(\"node-unreachable-text-visited\");\n\tconst weightText = document.getElementById(`node-weight-${animations[i].id}`);\n\tweightText.classList.add(\"node-weight-visited\");\n\tweightText.innerHTML = \"Infinite\";\n};\n\nconst setNodeFinal = (node_weights, animations, i) => {\n\tdocument\n\t\t.getElementById(`node-${animations[i].id}`)\n\t\t.classList.add(\"node-cycle-found\");\n\tdocument\n\t\t.getElementById(`node-text-${animations[i].id}`)\n\t\t.classList.add(\"node-cycle-found-text\");\n\tconst weightText = document.getElementById(`node-weight-${animations[i].id}`);\n\tweightText.classList.add(\"node-weight-visited\");\n\tweightText.innerHTML =\n\t\tnode_weights[animations[i].id] === 0\n\t\t\t? \"Start\"\n\t\t\t: node_weights[animations[i].id];\n};\n\n//Animate graph traversals\nexport const animateTraversal = (\n\tanimations,\n\tsetAnimateDone,\n\tfind_cycle = []\n) => {\n\t//Add an attribute to nodes and arrows (isAnimated) and set to true... then use css to handle the animation\n\t//or use document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n\n\tfor (let i = 0; i < animations.length; ++i) {\n\t\tif (\n\t\t\tanimations[i].type === \"node\" &&\n\t\t\t!(find_cycle.length && find_cycle[0] && i === animations.length - 1)\n\t\t) {\n\t\t\t//Animate node (only have visited property in dict)\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument\n\t\t\t\t\t.getElementById(`node-${animations[i].id}`)\n\t\t\t\t\t.classList.add(\"node-visited\");\n\t\t\t\tdocument\n\t\t\t\t\t.getElementById(`node-text-${animations[i].id}`)\n\t\t\t\t\t.classList.add(\"node-text-visited\");\n\t\t\t\t// document.getElementById(`node-${animations[i]}`).className = \"node-visited\";\n\t\t\t}, i * ANIMATION_SPEED_MS);\n\t\t} else if (animations[i].type === \"arrow\") {\n\t\t\t//Animate arrow\n\t\t\tanimateArrow(animations[i], i);\n\t\t}\n\t}\n\n\tif (find_cycle.length) {\n\t\tconst last_element = animations.length - 1;\n\t\tsetTimeout(() => {\n\t\t\tif (find_cycle[0]) {\n\t\t\t\tdocument\n\t\t\t\t\t.getElementById(`node-${animations[last_element].id}`)\n\t\t\t\t\t.classList.add(\"node-cycle-found\");\n\t\t\t\tdocument\n\t\t\t\t\t.getElementById(`node-text-${animations[last_element].id}`)\n\t\t\t\t\t.classList.add(\"node-cycle-found-text\");\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (find_cycle[0]) {\n\t\t\t\t\talert(\"Cycle found\");\n\t\t\t\t} else {\n\t\t\t\t\talert(\"No cycle found\");\n\t\t\t\t}\n\t\t\t}, 750);\n\t\t}, ANIMATION_SPEED_MS * last_element);\n\t}\n\n\t//Signal that animation is done to make reset button available\n\tsetTimeout(() => {\n\t\tsetAnimateDone(true);\n\t}, ANIMATION_SPEED_MS * animations.length + 200);\n};\n\n//Animate Dijsktra's Algorithm\nexport const animateDijkstra = (\n\tanimations,\n\tnode_weights,\n\tsetAnimateDone,\n\tendNode = false,\n\tendNodeReachable = false\n) => {\n\tlet slow_count = 0;\n\tconst stopAt = endNode ? animations.length - 1 : animations.length;\n\tfor (let i = 0; i < stopAt; ++i) {\n\t\tif (\n\t\t\tanimations[i].type === \"node\" &&\n\t\t\tnode_weights[animations[i].id] < Infinity\n\t\t) {\n\t\t\t//Animate node\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetNodeToVisitedWeight(node_weights, animations, i);\n\t\t\t}, i * ANIMATION_SPEED_MS);\n\t\t} else if (animations[i].type === \"node\") {\n\t\t\t//Unreached nodes\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetNodeUnreachable(animations, i);\n\t\t\t}, i * ANIMATION_SPEED_MS + slow_count * SLOW_ANIMATION);\n\t\t\tslow_count++;\n\t\t} else if (animations[i].type === \"arrow\") {\n\t\t\t//Animate arrow\n\t\t\tanimateArrow(animations[i], i);\n\t\t}\n\t}\n\n\tconst last_element = animations.length - 1;\n\tif (endNode && endNodeReachable) {\n\t\tsetTimeout(() => {\n\t\t\tsetNodeFinal(node_weights, animations, last_element);\n\t\t}, last_element * ANIMATION_SPEED_MS);\n\t} else if (endNode) {\n\t\tsetTimeout(() => {\n\t\t\tsetNodeUnreachable(animations, last_element);\n\t\t\tsetTimeout(() => {\n\t\t\t\talert(\"End Node Not Reachable\");\n\t\t\t}, 1000);\n\t\t}, ANIMATION_SPEED_MS * last_element);\n\t}\n\n\t//Signal that animation is done to make reset button available\n\tsetTimeout(() => {\n\t\tsetAnimateDone(true);\n\t}, ANIMATION_SPEED_MS * animations.length + SLOW_ANIMATION * slow_count + 200);\n};\n\n//Animate A* Algorithm\nexport const animateAStar = (\n\tanimations,\n\tnode_weights,\n\tendNodeReachable,\n\tsetAnimateDone\n) => {\n\tfor (let i = 0; i < animations.length - 1; ++i) {\n\t\tif (animations[i].type === \"node\") {\n\t\t\t//Animate node\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetNodeToVisitedWeight(node_weights, animations, i);\n\t\t\t}, i * ANIMATION_SPEED_MS);\n\t\t} else if (animations[i].type === \"arrow\") {\n\t\t\t//Animate arrow\n\t\t\tanimateArrow(animations[i], i);\n\t\t}\n\t}\n\tconst last_element = animations.length - 1;\n\tif (endNodeReachable) {\n\t\tsetTimeout(() => {\n\t\t\tsetNodeFinal(node_weights, animations, last_element);\n\t\t}, last_element * ANIMATION_SPEED_MS);\n\t} else {\n\t\tsetTimeout(() => {\n\t\t\tsetNodeUnreachable(animations, last_element);\n\t\t\tsetTimeout(() => {\n\t\t\t\talert(\"End Node Not Reachable\");\n\t\t\t}, 1000);\n\t\t}, ANIMATION_SPEED_MS * last_element);\n\t}\n\n\tconst slow_count = endNodeReachable ? 0 : 1;\n\n\t//Signal that animation is done to make reset button available\n\tsetTimeout(() => {\n\t\tsetAnimateDone(true);\n\t}, ANIMATION_SPEED_MS * animations.length + slow_count * SLOW_ANIMATION + 200);\n};\n","import \"./DijkstraPopup.css\";\nimport React from \"react\";\n\nexport function DijkstraPopup(props) {\n\tconst { handleClose, toggleStartAnimationNode } = props;\n\n\treturn (\n\t\t<div className=\"popup-box\">\n\t\t\t<div className=\"box\">\n\t\t\t\t<span className=\"close-icon\" onClick={handleClose}>\n\t\t\t\t\tx\n\t\t\t\t</span>\n\t\t\t\t<div className=\"row\">\n\t\t\t\t\t<button\n\t\t\t\t\t\tclassName=\"popupButton\"\n\t\t\t\t\t\tonClick={() => toggleStartAnimationNode(\"dijkstraFull\")}\n\t\t\t\t\t>\n\t\t\t\t\t\tTraverse Entire Graph\n\t\t\t\t\t</button>\n\t\t\t\t\t<button\n\t\t\t\t\t\tclassName=\"popupButton\"\n\t\t\t\t\t\tonClick={() => toggleStartAnimationNode(\"dijkstraStartEnd\")}\n\t\t\t\t\t>\n\t\t\t\t\t\tSelect Start and End Node\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n","import \"./Graph.css\";\nimport React, { useState } from \"react\";\nimport { Sidebar } from \"./Sidebar.js\";\nimport { graphSearch } from \"../Algorithms/GraphSearch\";\nimport { findCycle } from \"../Algorithms/FindCycle\";\nimport { Dijkstra } from \"../Algorithms/Dijkstra\";\nimport { AStar } from \"../Algorithms/AStar\";\nimport {\n\tNODE_RADIUS,\n\tsortNodesArray,\n\tfindNodeFromID,\n\tupdateMovedNodeLinks,\n\tgetAngle,\n\tgetStartOffsets,\n\tgetEndOffsets,\n} from \"./Helpers.js\";\nimport {\n\tanimateTraversal,\n\tanimateDijkstra,\n\tanimateAStar,\n} from \"./Animations.js\";\nimport { DijkstraPopup } from \"./DijkstraPopup\";\n\n//Consts\nconst LOCKED_MULTIPLIER = 1.44;\nconst CONTAINER_HEIGHT = 500;\nexport const CONTAINER_WIDTH = 1000;\nconst BUFFER = 15;\n\nexport function Graph() {\n\tconst [drawGraph, setDrawGraph] = useState(true); //mode for drawing graph (lock/unlock graph)\n\tconst [numNodes, setNumNodes] = useState(1); //used to give unique id to each new node (doesn't decrement when a node is deleted)\n\tconst [nodes, setNodes] = useState([]); //list of node objects\n\tconst [startLineNode, setStartLineNode] = useState(null); //starting node when connecting nodes\n\tconst [numArrows, setNumArrows] = useState(1); //used to give unique id to each new arrow (doesn't decrement when an arrow is deleted)\n\tconst [arrows, setArrows] = useState([]); //list of arrow objects\n\tconst [animationArrow, setAnimationArrow] = useState(null); //used to draw the realtime animated arrow when connecting two nodes\n\tconst [deleteMode, setDeleteMode] = useState(false); //true if delete mode is enabled\n\tconst [hoverNode, setHoverNode] = useState(null); //if delete mode is on, this is the node that is being hovered over\n\tconst [hoverArrow, setHoverArrow] = useState(null); //if delete mode is on, this is the link that is being hovered over\n\tconst [moveMode, setMoveMode] = useState(false); //true if move mode is enabled\n\tconst [animationNode, setAnimationNode] = useState(null); //realtime animated node when moving a node\n\tconst [originalNode, setOriginalNode] = useState(null); //outline of original node when when moving a node\n\tconst [weighted, setWeighted] = useState(false); //true if graph is weighted\n\tconst [directed, setDirected] = useState(true); //true if graph is directed\n\tconst [algorithmType, setAlgorithmType] = useState(\"\");\n\tconst [animate, setAnimate] = useState(false); //true if animation is currently in progress\n\tconst [animateDone, setAnimateDone] = useState(false); //true when animation finishing executing\n\tconst [animationStartNode, setAnimationStartNode] = useState(null); //start node for A* and Dijkstra Algorithm\n\tconst [popupOpen, setPopupOpen] = useState(false);\n\n\tconst ARROW_WIDTH = weighted ? 11 : 8; //px\n\n\t//Handles event when canvas is clicked\n\tconst handleCanvasClicked = (e) => {\n\t\tif (\n\t\t\te.target.className === \"node\" ||\n\t\t\te.button !== 0 ||\n\t\t\tdeleteMode ||\n\t\t\t!drawGraph\n\t\t)\n\t\t\treturn;\n\t\telse if (\n\t\t\te.nativeEvent.offsetX < NODE_RADIUS ||\n\t\t\te.nativeEvent.offsetY < NODE_RADIUS ||\n\t\t\tCONTAINER_WIDTH - e.nativeEvent.offsetX < NODE_RADIUS ||\n\t\t\tCONTAINER_HEIGHT - e.nativeEvent.offsetY < NODE_RADIUS\n\t\t)\n\t\t\treturn; //Keeps all drawn node inside the canvas\n\n\t\tconst coord_x = e.nativeEvent.offsetX;\n\t\tconst coord_y = e.nativeEvent.offsetY;\n\t\tlet update = true;\n\t\tlet idx = 0;\n\n\t\t//Check if adding a new node at the clicked location would overlap an existing node\n\t\twhile (idx < nodes.length && update) {\n\t\t\tconst distance = Math.sqrt(\n\t\t\t\tMath.pow(nodes[idx].x - coord_x, 2) +\n\t\t\t\t\tMath.pow(nodes[idx].y - coord_y, 2)\n\t\t\t);\n\t\t\tif (distance < 2 * NODE_RADIUS + BUFFER) {\n\t\t\t\tupdate = false; //Prevents two node from being on top of each other\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\n\t\tif (update) {\n\t\t\tif (animationNode) {\n\t\t\t\t//Node was just moved\n\t\t\t\t//Move links to new node location\n\t\t\t\tconst arrows_copy = arrows.slice();\n\t\t\t\tconst double_connections = [];\n\t\t\t\tfor (let i = 0; i < arrows_copy.length; i++) {\n\t\t\t\t\tif (!double_connections.includes(arrows_copy[i].id)) {\n\t\t\t\t\t\tif (arrows_copy[i].startID === animationNode.id) {\n\t\t\t\t\t\t\tupdateMovedNodeLinks(\n\t\t\t\t\t\t\t\tanimationNode,\n\t\t\t\t\t\t\t\tfindNodeFromID(arrows_copy[i].endID, nodes),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\tarrows_copy,\n\t\t\t\t\t\t\t\tdouble_connections,\n\t\t\t\t\t\t\t\tARROW_WIDTH,\n\t\t\t\t\t\t\t\tdirected\n\t\t\t\t\t\t\t); //arrows_copy and double_connections updated in function\n\t\t\t\t\t\t} else if (arrows_copy[i].endID === animationNode.id) {\n\t\t\t\t\t\t\tupdateMovedNodeLinks(\n\t\t\t\t\t\t\t\tfindNodeFromID(arrows_copy[i].startID, nodes),\n\t\t\t\t\t\t\t\tanimationNode,\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\tarrows_copy,\n\t\t\t\t\t\t\t\tdouble_connections,\n\t\t\t\t\t\t\t\tARROW_WIDTH,\n\t\t\t\t\t\t\t\tdirected\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsetArrows(arrows_copy);\n\t\t\t\tsetNodes([...nodes, animationNode]);\n\t\t\t\tsetMoveMode(false);\n\t\t\t\tsetAnimationNode(null);\n\t\t\t\tsetOriginalNode(null);\n\t\t\t} else if (!moveMode) {\n\t\t\t\t//Adding a new node\n\t\t\t\tsetNodes([\n\t\t\t\t\t...nodes,\n\t\t\t\t\t{ x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY, id: numNodes },\n\t\t\t\t]);\n\t\t\t\tsetNumNodes(numNodes + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\t//Handle clicking on a node\n\tconst handleNodeClicked = (e, node) => {\n\t\tif (e.button === 0 && !animationNode && drawGraph) {\n\t\t\t//Only primary click and not when node is being moved\n\t\t\tif (deleteMode) {\n\t\t\t\t//Handle deleting node\n\t\t\t\t//Remove node from nodes and any connections with node.id at either start or end of link\n\t\t\t\tconst nodes_copy = sortNodesArray(nodes.slice()); //Order by id\n\t\t\t\tlet i = 0;\n\t\t\t\tlet found = false;\n\t\t\t\twhile (i < nodes_copy.length) {\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\t//Decrement any node that has id > id of deleted node\n\t\t\t\t\t\t--nodes_copy[i].id;\n\t\t\t\t\t\t++i;\n\t\t\t\t\t} else if (nodes_copy[i].id === node.id) {\n\t\t\t\t\t\tnodes_copy.splice(i, 1);\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remove arrows that are connected to node\n\t\t\t\tconst arrows_copy = arrows.slice();\n\t\t\t\ti = 0;\n\t\t\t\twhile (i < arrows_copy.length) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tarrows_copy[i].startID === node.id ||\n\t\t\t\t\t\tarrows_copy[i].endID === node.id\n\t\t\t\t\t) {\n\t\t\t\t\t\tarrows_copy.splice(i, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Decrement start and end id of every arrow with id > id of deleted node\n\t\t\t\t\t\tif (arrows_copy[i].startID > node.id) {\n\t\t\t\t\t\t\t--arrows_copy[i].startID;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (arrows_copy[i].endID > node.id) {\n\t\t\t\t\t\t\t--arrows_copy[i].endID;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsetHoverNode(null);\n\t\t\t\tsetNodes(nodes_copy);\n\t\t\t\tsetArrows(arrows_copy);\n\t\t\t\t//Don't use the arrows id anywhere where order matters so don't need to reset\n\t\t\t\tsetNumNodes(numNodes - 1);\n\t\t\t} else if (moveMode) {\n\t\t\t\t//Handle moving node\n\t\t\t\t//Remove node from nodes list and set as animation node\n\t\t\t\tlet i = 0;\n\t\t\t\tconst nodes_copy = nodes.slice();\n\t\t\t\twhile (i < nodes_copy.length && nodes_copy[i].id !== node.id) {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\n\t\t\t\tif (i >= nodes_copy.length) {\n\t\t\t\t\talert(\"error\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tnodes_copy.splice(i, 1);\n\t\t\t\t\tsetAnimationNode(node);\n\t\t\t\t\tsetOriginalNode(node);\n\t\t\t\t\tsetNodes(nodes_copy);\n\t\t\t\t}\n\t\t\t} else if (!startLineNode) {\n\t\t\t\t//Start animation to draw new line\n\t\t\t\tsetStartLineNode(node); //Change colour & signal arrow animation\n\t\t\t\treturn;\n\t\t\t} else if (node.id !== startLineNode.id) {\n\t\t\t\t//connect nodes with arrows\n\t\t\t\tconnectNodes(node);\n\t\t\t}\n\t\t\tsetAnimationArrow(null);\n\t\t\tsetStartLineNode(null);\n\t\t} else if (e.button === 0 && !animate) {\n\t\t\tif (\n\t\t\t\talgorithmType === \"breadth-first-search\" ||\n\t\t\t\talgorithmType === \"depth-first-search\"\n\t\t\t) {\n\t\t\t\t//selecting start node for graph search\n\t\t\t\tconst breadthFirstSearch = algorithmType === \"breadth-first-search\";\n\t\t\t\tconst animations = graphSearch(\n\t\t\t\t\tnode,\n\t\t\t\t\tnodes,\n\t\t\t\t\tarrows,\n\t\t\t\t\tdirected,\n\t\t\t\t\tbreadthFirstSearch\n\t\t\t\t);\n\t\t\t\tsetAnimate(true);\n\t\t\t\tanimateTraversal(animations, setAnimateDone);\n\t\t\t} else if (algorithmType === \"find-cycle\") {\n\t\t\t\tconst [is_cycle, animations] = findCycle(node, nodes, arrows, directed);\n\t\t\t\tsetAnimate(true);\n\t\t\t\tanimateTraversal(animations, setAnimateDone, [is_cycle]);\n\t\t\t} else if (algorithmType === \"dijkstraFull\") {\n\t\t\t\tconst [node_weights, animations] = Dijkstra(\n\t\t\t\t\tnode,\n\t\t\t\t\tnodes,\n\t\t\t\t\tarrows,\n\t\t\t\t\tdirected\n\t\t\t\t);\n\t\t\t\tsetAnimate(true);\n\t\t\t\tanimateDijkstra(animations, node_weights, setAnimateDone);\n\t\t\t} else if (algorithmType === \"dijkstraStartEnd\") {\n\t\t\t\tif (animationStartNode && animationStartNode !== node.id) {\n\t\t\t\t\tconst [node_weights, animations] = Dijkstra(\n\t\t\t\t\t\tanimationStartNode,\n\t\t\t\t\t\tnodes,\n\t\t\t\t\t\tarrows,\n\t\t\t\t\t\tdirected,\n\t\t\t\t\t\tnode\n\t\t\t\t\t);\n\t\t\t\t\tsetAnimate(true);\n\t\t\t\t\tanimateDijkstra(\n\t\t\t\t\t\tanimations,\n\t\t\t\t\t\tnode_weights,\n\t\t\t\t\t\tsetAnimateDone,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tnode_weights[node.id] < Infinity\n\t\t\t\t\t);\n\t\t\t\t} else if (!animationStartNode) {\n\t\t\t\t\tsetAnimationStartNode(node);\n\t\t\t\t} else {\n\t\t\t\t\tsetAnimationStartNode(null);\n\t\t\t\t}\n\t\t\t} else if (algorithmType === \"A*\") {\n\t\t\t\tif (animationStartNode && animationStartNode.id !== node.id) {\n\t\t\t\t\tconst [animations, node_weights, endNodeReachable] = AStar(\n\t\t\t\t\t\tanimationStartNode,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tnodes,\n\t\t\t\t\t\tarrows,\n\t\t\t\t\t\tdirected,\n\t\t\t\t\t\tweighted\n\t\t\t\t\t);\n\t\t\t\t\tsetAnimate(true);\n\t\t\t\t\tanimateAStar(\n\t\t\t\t\t\tanimations,\n\t\t\t\t\t\tnode_weights,\n\t\t\t\t\t\tendNodeReachable,\n\t\t\t\t\t\tsetAnimateDone\n\t\t\t\t\t);\n\t\t\t\t} else if (!animationStartNode) {\n\t\t\t\t\tsetAnimationStartNode(node);\n\t\t\t\t} else {\n\t\t\t\t\tsetAnimationStartNode(null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tconst handleMouseUp = (node) => {\n\t\tif (\n\t\t\tdrawGraph &&\n\t\t\tstartLineNode &&\n\t\t\tnode.id !== startLineNode.id &&\n\t\t\t!deleteMode &&\n\t\t\t!moveMode\n\t\t) {\n\t\t\t//connect nodes with arrows\n\t\t\tconnectNodes(node);\n\t\t\tsetAnimationArrow(null);\n\t\t\tsetStartLineNode(null);\n\t\t}\n\t};\n\n\tconst connectNodes = (node) => {\n\t\tconst angle = getAngle(startLineNode, node);\n\t\tconst arrow_width = ARROW_WIDTH; //px\n\t\tlet [start_offsetx, start_offsety] = getStartOffsets(startLineNode, angle);\n\t\tlet [end_offsetx, end_offsety] = getEndOffsets(node, angle, directed);\n\n\t\t//Check for overlap of arrows\n\t\tlet connecting_arrows = 0; //Number of arrows currently between nodes\n\t\tlet doubleEdgeNodePair = -1; //Look for two nodes connected by two directional edges\n\t\tlet overlap = false;\n\t\tfor (let i = 0; i < arrows.length; i++) {\n\t\t\tconst arrow1 =\n\t\t\t\tstartLineNode.id === arrows[i].endID && node.id === arrows[i].startID;\n\t\t\tconst arrow2 =\n\t\t\t\tstartLineNode.id === arrows[i].startID && node.id === arrows[i].endID;\n\n\t\t\tif (arrow2) {\n\t\t\t\t//Trying to draw same line between already connected nodes\n\t\t\t\toverlap = true;\n\t\t\t} else if (arrow1) {\n\t\t\t\tconnecting_arrows += 1;\n\t\t\t\tdoubleEdgeNodePair = i; //Mark index of double connected nodes\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\toverlap ||\n\t\t\t(connecting_arrows === 1 && !directed) ||\n\t\t\tconnecting_arrows > 1\n\t\t) {\n\t\t\talert(\"Nodes already connected\");\n\t\t} else {\n\t\t\tlet numLinks = numArrows;\n\t\t\tif (doubleEdgeNodePair >= 0) {\n\t\t\t\t//Calculate required offset adjustment for doubly connected nodes\n\t\t\t\tstart_offsetx += arrow_width * Math.sin(angle);\n\t\t\t\tstart_offsety += arrow_width * Math.cos(angle);\n\t\t\t\tend_offsetx += arrow_width * Math.sin(angle);\n\t\t\t\tend_offsety += arrow_width * Math.cos(angle);\n\t\t\t\tconst replacement = {\n\t\t\t\t\tnodex1:\n\t\t\t\t\t\tarrows[doubleEdgeNodePair].nodex1 - arrow_width * Math.sin(angle),\n\t\t\t\t\tnodey1:\n\t\t\t\t\t\tarrows[doubleEdgeNodePair].nodey1 - arrow_width * Math.cos(angle),\n\t\t\t\t\tnodex2:\n\t\t\t\t\t\tarrows[doubleEdgeNodePair].nodex2 - arrow_width * Math.sin(angle),\n\t\t\t\t\tnodey2:\n\t\t\t\t\t\tarrows[doubleEdgeNodePair].nodey2 - arrow_width * Math.cos(angle),\n\t\t\t\t\tstartID: node.id,\n\t\t\t\t\tendID: startLineNode.id,\n\t\t\t\t\tid: numLinks,\n\t\t\t\t\tweight: arrows[doubleEdgeNodePair].weight,\n\t\t\t\t};\n\t\t\t\tarrows.splice(doubleEdgeNodePair, 1, replacement); //Replace current line by updated offset\n\t\t\t\tnumLinks++;\n\t\t\t}\n\t\t\tsetArrows([\n\t\t\t\t...arrows,\n\t\t\t\t{\n\t\t\t\t\tnodex1: start_offsetx,\n\t\t\t\t\tnodey1: start_offsety,\n\t\t\t\t\tnodex2: end_offsetx,\n\t\t\t\t\tnodey2: end_offsety,\n\t\t\t\t\tstartID: startLineNode.id,\n\t\t\t\t\tendID: node.id,\n\t\t\t\t\tid: numLinks,\n\t\t\t\t\tweight: 1,\n\t\t\t\t},\n\t\t\t]);\n\t\t\tsetNumArrows(numLinks + 1);\n\t\t}\n\t};\n\n\t//Check if deletemode and set colour accordingly (do same for links)\n\tconst handleElementHover = (e, id) => {\n\t\tif (animate) return;\n\n\t\tif (e.type === \"mouseenter\" && e.target.className.baseVal) {\n\t\t\tif (e.target.className.baseVal.indexOf(\"node\") === 0) {\n\t\t\t\tsetHoverNode(id);\n\t\t\t} else if (e.target.className.baseVal.indexOf(\"arrow\") === 0) {\n\t\t\t\tsetHoverArrow(id);\n\t\t\t}\n\t\t} else {\n\t\t\tsetHoverNode(null);\n\t\t\tsetHoverArrow(null);\n\t\t}\n\t};\n\n\t//Handle animating arrow in real-time\n\tconst handleArrowAnimation = (e) => {\n\t\tif (e.target.className === \"weight-input\") {\n\t\t\t//turn off animation when hoving over weight text\n\t\t\tsetAnimationArrow(null);\n\t\t} else if (moveMode && animationNode) {\n\t\t\t//Draw the animated node if currently moving a node\n\t\t\tsetAnimationNode({\n\t\t\t\tx: e.nativeEvent.offsetX,\n\t\t\t\ty: e.nativeEvent.offsetY,\n\t\t\t\tid: animationNode.id,\n\t\t\t});\n\t\t} else if (startLineNode) {\n\t\t\t//Draw the animated arrow if a startnode has been selected\n\t\t\tconst distance = Math.sqrt(\n\t\t\t\tMath.pow(e.nativeEvent.offsetX - startLineNode.x, 2) +\n\t\t\t\t\tMath.pow(e.nativeEvent.offsetY - startLineNode.y, 2)\n\t\t\t);\n\n\t\t\tif (distance < 2 * NODE_RADIUS + BUFFER) {\n\t\t\t\t//Nodes that are too close (shouldn't happen) will not get connected\n\t\t\t\tsetAnimationArrow(null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst pointer_coords = {\n\t\t\t\tx: e.nativeEvent.offsetX,\n\t\t\t\ty: e.nativeEvent.offsetY,\n\t\t\t};\n\t\t\tconst angle = getAngle(startLineNode, pointer_coords);\n\t\t\tconst [start_offsetx, start_offsety] = getStartOffsets(\n\t\t\t\tstartLineNode,\n\t\t\t\tangle\n\t\t\t);\n\n\t\t\tconst pointer_size = directed ? 12 : 2;\n\t\t\tconst pointerx = pointer_size * Math.cos(angle);\n\t\t\tconst pointery = pointer_size * Math.sin(angle);\n\t\t\tconst end_offsetx = e.nativeEvent.offsetX - pointerx;\n\t\t\tconst end_offsety = e.nativeEvent.offsetY + pointery;\n\n\t\t\tsetAnimationArrow({\n\t\t\t\tstartx: start_offsetx,\n\t\t\t\tstarty: start_offsety,\n\t\t\t\tendx: end_offsetx,\n\t\t\t\tendy: end_offsety,\n\t\t\t});\n\t\t} else if (animationArrow) {\n\t\t\t//Error handling\n\t\t\tsetAnimationArrow(null);\n\t\t}\n\t};\n\n\t//Handle action for clicking on an arrow (for deleting)\n\tconst handleLinkClick = (link) => {\n\t\tif (deleteMode) {\n\t\t\tlet connectedNodes = {};\n\t\t\tconst arrows_copy = arrows.slice();\n\t\t\tlet i = 0;\n\t\t\t//Find index of link to be deleted\n\t\t\twhile (i < arrows_copy.length && arrows_copy[i].id !== link.id) {\n\t\t\t\t++i;\n\t\t\t}\n\n\t\t\tif (i < arrows_copy.length) {\n\t\t\t\t//Delete link from arrows array\n\t\t\t\tconnectedNodes.startID = arrows_copy[i].startID;\n\t\t\t\tconnectedNodes.endID = arrows_copy[i].endID;\n\t\t\t\tarrows_copy.splice(i, 1);\n\n\t\t\t\t//Check if there is another link that needs to be moved\n\t\t\t\tconst arrow_width = ARROW_WIDTH; //px\n\t\t\t\tlet i_paired_link = 0;\n\t\t\t\twhile (\n\t\t\t\t\ti_paired_link < arrows_copy.length &&\n\t\t\t\t\t!(\n\t\t\t\t\t\tarrows_copy[i_paired_link].startID === connectedNodes.endID &&\n\t\t\t\t\t\tarrows_copy[i_paired_link].endID === connectedNodes.startID\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t++i_paired_link;\n\t\t\t\t}\n\n\t\t\t\t//If arrow was originally doubly connected, move 2nd arrow to middle\n\t\t\t\tif (i_paired_link < arrows_copy.length) {\n\t\t\t\t\t//Offset coordinates but angle is still the same\n\t\t\t\t\tconst endNode = {\n\t\t\t\t\t\tx: arrows_copy[i_paired_link].nodex2,\n\t\t\t\t\t\ty: arrows_copy[i_paired_link].nodey2,\n\t\t\t\t\t};\n\t\t\t\t\tconst startNode = {\n\t\t\t\t\t\tx: arrows_copy[i_paired_link].nodex1,\n\t\t\t\t\t\ty: arrows_copy[i_paired_link].nodey1,\n\t\t\t\t\t};\n\t\t\t\t\tconst angle = getAngle(startNode, endNode);\n\n\t\t\t\t\tarrows_copy[i_paired_link].nodex1 -= arrow_width * Math.sin(angle);\n\t\t\t\t\tarrows_copy[i_paired_link].nodey1 -= arrow_width * Math.cos(angle);\n\t\t\t\t\tarrows_copy[i_paired_link].nodex2 -= arrow_width * Math.sin(angle);\n\t\t\t\t\tarrows_copy[i_paired_link].nodey2 -= arrow_width * Math.cos(angle);\n\t\t\t\t}\n\t\t\t\tsetArrows(arrows_copy);\n\t\t\t\tsetHoverArrow(null);\n\t\t\t}\n\t\t}\n\t};\n\n\t//Handle interrupting moving a node (click another option or something)\n\tconst handleMoveNodeInterrupt = () => {\n\t\tconst temp = nodes.slice();\n\t\ttemp.push(originalNode);\n\t\tsetNodes(temp);\n\t\tsetAnimationNode(null);\n\t\tsetOriginalNode(null);\n\t};\n\n\t//Click on Delete Node/Link\n\tconst toggleDeleteMode = () => {\n\t\tsetStartLineNode(null);\n\t\tsetDeleteMode(!deleteMode);\n\t\tsetMoveMode(false);\n\t\tif (animationNode) {\n\t\t\thandleMoveNodeInterrupt();\n\t\t}\n\t};\n\n\t//Click on Move Node\n\tconst toggleMoveMode = () => {\n\t\tsetStartLineNode(null);\n\t\tsetMoveMode(!moveMode);\n\t\tsetDeleteMode(false);\n\t\tif (animationNode) {\n\t\t\thandleMoveNodeInterrupt();\n\t\t}\n\t};\n\n\t//Lock / Unlock graph\n\tconst toggleDrawGraph = () => {\n\t\t//Update arrows and nodes to maintain distancing\n\t\tconst arrows_copy = arrows.slice();\n\t\tconst double_connections = [];\n\t\tconst nodes_copy = nodes.slice();\n\n\t\t//Scale the nodes in the canvas accordingly to the new size\n\t\tnodes_copy.forEach((node) => {\n\t\t\tif (drawGraph) {\n\t\t\t\t//Locking draw\n\t\t\t\tnode.x *= LOCKED_MULTIPLIER;\n\t\t\t\tnode.y *= LOCKED_MULTIPLIER;\n\t\t\t} else {\n\t\t\t\t//Unlocking draw\n\t\t\t\tnode.x /= LOCKED_MULTIPLIER;\n\t\t\t\tnode.y /= LOCKED_MULTIPLIER;\n\t\t\t}\n\t\t});\n\n\t\tfor (let i = 0; i < arrows_copy.length; i++) {\n\t\t\tif (!double_connections.includes(arrows_copy[i].id)) {\n\t\t\t\tupdateMovedNodeLinks(\n\t\t\t\t\tfindNodeFromID(arrows_copy[i].startID, nodes_copy),\n\t\t\t\t\tfindNodeFromID(arrows_copy[i].endID, nodes_copy),\n\t\t\t\t\ti,\n\t\t\t\t\tarrows_copy,\n\t\t\t\t\tdouble_connections,\n\t\t\t\t\tARROW_WIDTH,\n\t\t\t\t\tdirected\n\t\t\t\t); //arrows_copy and double_connections updated in function\n\t\t\t}\n\t\t}\n\n\t\thandleGraphReset();\n\n\t\tsetNodes(nodes_copy);\n\t\tsetArrows(arrows_copy);\n\t\tsetDrawGraph(!drawGraph);\n\t\tsetMoveMode(false);\n\t\tsetDeleteMode(false);\n\t\tsetAnimationArrow(null);\n\t\tsetStartLineNode(null);\n\t\tif (animationNode) {\n\t\t\thandleMoveNodeInterrupt();\n\t\t}\n\t};\n\n\t//Change graphtype to directed / undirected\n\tconst toggleDirected = (val) => {\n\t\tif (val && val !== directed) {\n\t\t\t//Set to directed (don't consider any double edges)\n\t\t\tconst new_arrows = arrows.slice();\n\n\t\t\tfor (let i = 0; i < new_arrows.length; i++) {\n\t\t\t\tupdateMovedNodeLinks(\n\t\t\t\t\tfindNodeFromID(new_arrows[i].startID, nodes),\n\t\t\t\t\tfindNodeFromID(new_arrows[i].endID, nodes),\n\t\t\t\t\ti,\n\t\t\t\t\tnew_arrows,\n\t\t\t\t\t[],\n\t\t\t\t\tARROW_WIDTH\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tsetArrows(new_arrows);\n\t\t} else if (val !== directed) {\n\t\t\t//Set to undirected\n\t\t\tconst new_arrows = [];\n\t\t\t//Get rid of double edges\n\t\t\tfor (let i = 0; i < arrows.length; ++i) {\n\t\t\t\tlet include = true;\n\t\t\t\tlet j = 0;\n\t\t\t\twhile (j < new_arrows.length && include) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tnew_arrows[j].startID === arrows[i].endID &&\n\t\t\t\t\t\tnew_arrows[j].endID === arrows[i].startID\n\t\t\t\t\t) {\n\t\t\t\t\t\tinclude = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (include) {\n\t\t\t\t\tnew_arrows.push(arrows[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < new_arrows.length; i++) {\n\t\t\t\tupdateMovedNodeLinks(\n\t\t\t\t\tfindNodeFromID(new_arrows[i].startID, nodes),\n\t\t\t\t\tfindNodeFromID(new_arrows[i].endID, nodes),\n\t\t\t\t\ti,\n\t\t\t\t\tnew_arrows,\n\t\t\t\t\t[],\n\t\t\t\t\tARROW_WIDTH,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tsetArrows(new_arrows);\n\t\t}\n\t\tsetDirected(val);\n\t};\n\n\t//Change graphtype to weighted / unweighted\n\tconst toggleWeighted = (val) => {\n\t\t//Update arrows and nodes to add appropriate distancing\n\t\tconst arrows_copy = arrows.slice();\n\t\tconst double_connections = [];\n\t\tconst arrow_width = val ? 11 : 8; //11 for setting weighted and 8 for setting unweighted\n\t\tif (directed && val !== weighted) {\n\t\t\tfor (let i = 0; i < arrows_copy.length; i++) {\n\t\t\t\tif (!double_connections.includes(arrows_copy[i].id)) {\n\t\t\t\t\tupdateMovedNodeLinks(\n\t\t\t\t\t\tfindNodeFromID(arrows_copy[i].startID, nodes),\n\t\t\t\t\t\tfindNodeFromID(arrows_copy[i].endID, nodes),\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tarrows_copy,\n\t\t\t\t\t\tdouble_connections,\n\t\t\t\t\t\tarrow_width,\n\t\t\t\t\t\tdirected,\n\t\t\t\t\t\tval\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsetWeighted(val);\n\t\tsetArrows(arrows_copy);\n\t};\n\n\t//Change the sidebar to display the different graph options\n\tconst handleChangeGraphType = () => {\n\t\tsetMoveMode(false);\n\t\tsetDeleteMode(false);\n\t\tif (animationNode) {\n\t\t\thandleMoveNodeInterrupt();\n\t\t}\n\t};\n\n\t//Clear graph of all nodes / arrows\n\tconst clearGraph = () => {\n\t\tif (window.confirm(\"Are you sure you want to delete your graph?\")) {\n\t\t\tsetNodes([]);\n\t\t\tsetArrows([]);\n\t\t\tsetNumNodes(1);\n\t\t\tsetStartLineNode(null);\n\t\t\tsetNumArrows(1);\n\t\t\tsetAnimationArrow(null);\n\t\t\tsetDeleteMode(false);\n\t\t\tsetMoveMode(false);\n\t\t\tsetAnimationNode(null);\n\t\t\tsetOriginalNode(null);\n\t\t}\n\t};\n\n\t//Updates weight of arrow\n\tconst updateArrowWeight = (e, id) => {\n\t\tif (!drawGraph) return; //Don't update if canvas is locked\n\n\t\tconst arrows_copy = arrows.slice();\n\t\tlet i = 0;\n\t\t//Find arrow whose weight is being updated\n\t\twhile (i < arrows_copy.length && arrows_copy[i].id !== id) {\n\t\t\ti++;\n\t\t}\n\n\t\t//Errror handling for id not found\n\t\tif (i >= arrows_copy.length) {\n\t\t\talert(\"Error\");\n\t\t\treturn;\n\t\t} else if (e.target.value[0] === \"0\") {\n\t\t\t//Avoid case of adding 0s to the front\n\t\t\te.target.value = e.target.value.substr(1);\n\t\t}\n\n\t\tconst eventNum = parseInt(e.target.value); //Value typed into input box\n\t\tconst addedValue = parseInt(e.nativeEvent.data); //New number added to input box\n\t\tconst prevValue = arrows_copy[i].weight; //Previous value in input box\n\t\tconst MAX = 50; //Max weight\n\t\tconst MIN = 1; //Min weight\n\n\t\tif (!eventNum) {\n\t\t\t//Delete a single digit\n\t\t\tarrows_copy[i].weight = MIN;\n\t\t} else if (eventNum > MAX && prevValue < 10) {\n\t\t\t//Replace current digit to avoid going over MAX (if max < 100)\n\t\t\tarrows_copy[i].weight = addedValue === 0 ? MIN : addedValue;\n\t\t} else if (!addedValue && eventNum <= MAX) {\n\t\t\t//Delete a digit\n\t\t\tarrows_copy[i].weight = eventNum;\n\t\t} else if (prevValue < Math.floor(MAX / 10)) {\n\t\t\t//Append to single digit if adding another digit would be less than max\n\t\t\tarrows_copy[i].weight = eventNum;\n\t\t} else if (\n\t\t\tprevValue >= 10 &&\n\t\t\te.target.value.indexOf(String(prevValue)) === 0\n\t\t) {\n\t\t\t//Adding a number to the end\n\t\t\tarrows_copy[i].weight = Math.floor(prevValue / 10) * 10 + addedValue;\n\t\t} else if (\n\t\t\tprevValue >= 10 &&\n\t\t\te.target.value.indexOf(String(prevValue)) === -1\n\t\t) {\n\t\t\t//Adding a number to the end (from middle)\n\t\t\tarrows_copy[i].weight = Math.floor(prevValue / 10) * 10 + addedValue;\n\t\t} else if (\n\t\t\tprevValue >= 10 &&\n\t\t\te.target.value.indexOf(String(addedValue)) === 0 &&\n\t\t\tMath.floor(eventNum / 10) < MAX\n\t\t) {\n\t\t\t//Adding a number to the start\n\t\t\tarrows_copy[i].weight = Math.floor(eventNum / 10);\n\t\t}\n\n\t\tsetArrows(arrows_copy);\n\t};\n\n\tconst toggleStartAnimationNode = (type) => {\n\t\tif (popupOpen) {\n\t\t\ttogglePopup();\n\t\t}\n\n\t\tsetAnimationStartNode(null);\n\n\t\tif (type !== algorithmType) {\n\t\t\tsetAlgorithmType(type);\n\t\t} else {\n\t\t\tsetAlgorithmType(\"\");\n\t\t}\n\t};\n\n\tconst handleGraphReset = () => {\n\t\tconst nodes_copy = nodes.slice();\n\t\tconst arrows_copy = arrows.slice();\n\n\t\tnodes_copy.forEach((node) => {\n\t\t\tdocument.getElementById(`node-${node.id}`).className.baseVal = \"node\";\n\t\t\tdocument.getElementById(`node-text-${node.id}`).className.baseVal =\n\t\t\t\t\"node-number\";\n\t\t\tif (algorithmType === \"dijkstra\") {\n\t\t\t\tdocument.getElementById(`node-weight-${node.id}`).className.baseVal =\n\t\t\t\t\t\"weight-hidden\";\n\t\t\t}\n\t\t});\n\n\t\tarrows_copy.forEach((arrow) => {\n\t\t\tdocument.getElementById(`arrow-${arrow.id}`).className.baseVal = \"arrow\";\n\t\t});\n\n\t\tsetAlgorithmType(\"\");\n\t\tsetAnimate(false);\n\t\tsetAnimateDone(false);\n\t\tsetHoverNode(null);\n\t\tsetAnimationStartNode(null);\n\t};\n\n\t//Toggles popup menu\n\tconst togglePopup = () => {\n\t\tif (algorithmType.indexOf(\"dijkstra\") === -1) {\n\t\t\tif (!animate && !animateDone) setPopupOpen(!popupOpen);\n\t\t}\n\t\tsetAlgorithmType(\"\");\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<h1 className=\"header\">\n\t\t\t\t{drawGraph\n\t\t\t\t\t? \"Draw Your Graph\"\n\t\t\t\t\t: !animate\n\t\t\t\t\t? algorithmType !== \"\"\n\t\t\t\t\t\t? animationStartNode\n\t\t\t\t\t\t\t? \"Select End Node\"\n\t\t\t\t\t\t\t: \"Select Starting Node\"\n\t\t\t\t\t\t: \"Select Graph Traversal\"\n\t\t\t\t\t: \"\"}\n\t\t\t</h1>\n\t\t\t<svg\n\t\t\t\tclassName={drawGraph ? \"canvas\" : \"canvas-locked\"}\n\t\t\t\theight={\n\t\t\t\t\tdrawGraph ? CONTAINER_HEIGHT : LOCKED_MULTIPLIER * CONTAINER_HEIGHT\n\t\t\t\t}\n\t\t\t\twidth={\n\t\t\t\t\tdrawGraph ? CONTAINER_WIDTH : LOCKED_MULTIPLIER * CONTAINER_WIDTH\n\t\t\t\t}\n\t\t\t\tonMouseDown={handleCanvasClicked}\n\t\t\t\tonMouseMove={handleArrowAnimation}\n\t\t\t>\n\t\t\t\t{directed && (\n\t\t\t\t\t<defs>\n\t\t\t\t\t\t<marker\n\t\t\t\t\t\t\tid=\"markerArrow\"\n\t\t\t\t\t\t\tmarkerWidth=\"8\"\n\t\t\t\t\t\t\tmarkerHeight=\"8\"\n\t\t\t\t\t\t\trefX=\"2\"\n\t\t\t\t\t\t\trefY=\"5\"\n\t\t\t\t\t\t\torient=\"auto\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<path d=\"M2,0 L2,7 L7,5 L2,3\" style={{ fill: \"#000000\" }} />\n\t\t\t\t\t\t</marker>\n\t\t\t\t\t\t<marker\n\t\t\t\t\t\t\tid=\"markerArrowDelete\"\n\t\t\t\t\t\t\tmarkerWidth=\"8\"\n\t\t\t\t\t\t\tmarkerHeight=\"8\"\n\t\t\t\t\t\t\trefX=\"2\"\n\t\t\t\t\t\t\trefY=\"5\"\n\t\t\t\t\t\t\torient=\"auto\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<path d=\"M2,0 L2,7 L7,5 L2,3\" style={{ fill: \"red\" }} />\n\t\t\t\t\t\t</marker>\n\t\t\t\t\t\t<marker\n\t\t\t\t\t\t\tid=\"markerArrowAnimation\"\n\t\t\t\t\t\t\tmarkerWidth=\"8\"\n\t\t\t\t\t\t\tmarkerHeight=\"8\"\n\t\t\t\t\t\t\trefX=\"2\"\n\t\t\t\t\t\t\trefY=\"5\"\n\t\t\t\t\t\t\torient=\"auto\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<path d=\"M2,0 L2,7 L7,5 L2,3\" style={{ fill: \"cyan\" }} />\n\t\t\t\t\t\t</marker>\n\t\t\t\t\t</defs>\n\t\t\t\t)}\n\n\t\t\t\t<g>\n\t\t\t\t\t{arrows.map((arrow, i) => (\n\t\t\t\t\t\t<g key={i}>\n\t\t\t\t\t\t\t<line\n\t\t\t\t\t\t\t\tid={`arrow-${arrow.id}`}\n\t\t\t\t\t\t\t\tx1={arrow.nodex1}\n\t\t\t\t\t\t\t\ty1={arrow.nodey1}\n\t\t\t\t\t\t\t\tx2={arrow.nodex2}\n\t\t\t\t\t\t\t\ty2={arrow.nodey2}\n\t\t\t\t\t\t\t\tclassName={`${\n\t\t\t\t\t\t\t\t\tdeleteMode && hoverArrow && hoverArrow === arrow.id\n\t\t\t\t\t\t\t\t\t\t? \"delete-arrow-hover\"\n\t\t\t\t\t\t\t\t\t\t: \"arrow\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\tonClick={() => handleLinkClick(arrow)}\n\t\t\t\t\t\t\t\tonMouseEnter={(e) => handleElementHover(e, arrow.id)}\n\t\t\t\t\t\t\t\tonMouseLeave={(e) => handleElementHover(e, arrow.id)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t{weighted && (\n\t\t\t\t\t\t\t\t<foreignObject\n\t\t\t\t\t\t\t\t\tx={(arrow.nodex1 + arrow.nodex2) / 2 - 13}\n\t\t\t\t\t\t\t\t\ty={(arrow.nodey1 + arrow.nodey2) / 2 - 10}\n\t\t\t\t\t\t\t\t\twidth=\"33\"\n\t\t\t\t\t\t\t\t\theight=\"24\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\t\tclassName={`weight-input ${\n\t\t\t\t\t\t\t\t\t\t\t!drawGraph ? \"weight-input-disabled\" : \"\"\n\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\t\t\t\tmin=\"1\"\n\t\t\t\t\t\t\t\t\t\tmax=\"50\"\n\t\t\t\t\t\t\t\t\t\tstep=\"1\"\n\t\t\t\t\t\t\t\t\t\tvalue={arrow.weight}\n\t\t\t\t\t\t\t\t\t\tonMouseEnter={() =>\n\t\t\t\t\t\t\t\t\t\t\thandleElementHover(\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"mouseenter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: { className: { baseVal: \"arrow\" } },\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tarrow.id\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tonMouseLeave={(e) => handleElementHover(e, arrow.id)}\n\t\t\t\t\t\t\t\t\t\tonChange={(e) => updateArrowWeight(e, arrow.id)}\n\t\t\t\t\t\t\t\t\t\tonClick={\n\t\t\t\t\t\t\t\t\t\t\tdeleteMode ? () => handleLinkClick(arrow) : undefined\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tstyle={deleteMode ? { color: \"transparent\" } : {}}\n\t\t\t\t\t\t\t\t\t/>{\" \"}\n\t\t\t\t\t\t\t\t\t{/*Adding the style to onClick handler avoids weird case where an input gets clicked when deleting another*/}\n\t\t\t\t\t\t\t\t</foreignObject>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</g>\n\t\t\t\t\t))}\n\t\t\t\t</g>\n\n\t\t\t\t<g id=\"animation-edges\"></g>\n\n\t\t\t\t<g>\n\t\t\t\t\t{nodes.map((node, i) => (\n\t\t\t\t\t\t<g key={i}>\n\t\t\t\t\t\t\t<circle\n\t\t\t\t\t\t\t\tid={`node-${node.id}`}\n\t\t\t\t\t\t\t\tclassName={`node ${\n\t\t\t\t\t\t\t\t\t!startLineNode && hoverNode && hoverNode === node.id //hover actions\n\t\t\t\t\t\t\t\t\t\t? deleteMode\n\t\t\t\t\t\t\t\t\t\t\t? \"delete-node-hover\" //hovering on node to delete\n\t\t\t\t\t\t\t\t\t\t\t: moveMode\n\t\t\t\t\t\t\t\t\t\t\t? \"move-node-hover\" //hovering on node to move\n\t\t\t\t\t\t\t\t\t\t\t: drawGraph && !startLineNode\n\t\t\t\t\t\t\t\t\t\t\t? \"draw-node-connection\" //hovering on node to start drawing arrow\n\t\t\t\t\t\t\t\t\t\t\t: algorithmType !== \"\"\n\t\t\t\t\t\t\t\t\t\t\t? \"select-start-node\" //hovering on node to start search\n\t\t\t\t\t\t\t\t\t\t\t: \"no-click-node\"\n\t\t\t\t\t\t\t\t\t\t: drawGraph\n\t\t\t\t\t\t\t\t\t\t? startLineNode && startLineNode.id === node.id\n\t\t\t\t\t\t\t\t\t\t\t? \"draw-node-connection\" //click on node and changes to orange\n\t\t\t\t\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t\t\t\t\t: animationStartNode && animationStartNode.id === node.id\n\t\t\t\t\t\t\t\t\t\t? \"select-start-node\"\n\t\t\t\t\t\t\t\t\t\t: \"no-click-node\"\n\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\tr={NODE_RADIUS}\n\t\t\t\t\t\t\t\tcx={node.x}\n\t\t\t\t\t\t\t\tcy={node.y}\n\t\t\t\t\t\t\t\tonMouseDown={(e) => handleNodeClicked(e, node)}\n\t\t\t\t\t\t\t\tonMouseUp={() => handleMouseUp(node)}\n\t\t\t\t\t\t\t\tonMouseEnter={(e) => handleElementHover(e, node.id)}\n\t\t\t\t\t\t\t\tonMouseLeave={(e) => handleElementHover(e, node.id)}\n\t\t\t\t\t\t\t></circle>\n\t\t\t\t\t\t\t<text\n\t\t\t\t\t\t\t\tid={`node-text-${node.id}`}\n\t\t\t\t\t\t\t\tx={node.x}\n\t\t\t\t\t\t\t\ty={node.y}\n\t\t\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\t\t\t(!drawGraph && algorithmType === \"\") || animate\n\t\t\t\t\t\t\t\t\t\t? \"no-click-node-number\"\n\t\t\t\t\t\t\t\t\t\t: \"node-number\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextAnchor=\"middle\"\n\t\t\t\t\t\t\t\tstroke=\"black\"\n\t\t\t\t\t\t\t\tstrokeWidth=\"0.5px\"\n\t\t\t\t\t\t\t\talignmentBaseline=\"middle\"\n\t\t\t\t\t\t\t\tonMouseDown={(e) => handleNodeClicked(e, node)}\n\t\t\t\t\t\t\t\tonMouseUp={() => handleMouseUp(node)}\n\t\t\t\t\t\t\t\tonMouseEnter={(e) => handleElementHover(e, node.id)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{node.id}\n\t\t\t\t\t\t\t</text>\n\t\t\t\t\t\t\t{(algorithmType.indexOf(\"dijkstra\") !== -1 ||\n\t\t\t\t\t\t\t\talgorithmType === \"A*\") &&\n\t\t\t\t\t\t\t\tanimate && (\n\t\t\t\t\t\t\t\t\t<text\n\t\t\t\t\t\t\t\t\t\tid={`node-weight-${node.id}`}\n\t\t\t\t\t\t\t\t\t\tx={node.x}\n\t\t\t\t\t\t\t\t\t\ty={node.y + 37.5}\n\t\t\t\t\t\t\t\t\t\tclassName={\"weight-hidden\"}\n\t\t\t\t\t\t\t\t\t\ttextAnchor=\"middle\"\n\t\t\t\t\t\t\t\t\t\tstrokeWidth=\"0.5px\"\n\t\t\t\t\t\t\t\t\t\talignmentBaseline=\"middle\"\n\t\t\t\t\t\t\t\t\t\tonMouseDown={(e) => handleNodeClicked(e, node)}\n\t\t\t\t\t\t\t\t\t\tonMouseUp={() => handleMouseUp(node)}\n\t\t\t\t\t\t\t\t\t\tonMouseEnter={(e) => handleElementHover(e, node.id)}\n\t\t\t\t\t\t\t\t\t></text>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</g>\n\t\t\t\t\t))}\n\t\t\t\t</g>\n\n\t\t\t\t{animationArrow && (\n\t\t\t\t\t<g>\n\t\t\t\t\t\t<line\n\t\t\t\t\t\t\tx1={animationArrow.startx}\n\t\t\t\t\t\t\ty1={animationArrow.starty}\n\t\t\t\t\t\t\tx2={animationArrow.endx}\n\t\t\t\t\t\t\ty2={animationArrow.endy}\n\t\t\t\t\t\t\tclassName=\"arrow\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</g>\n\t\t\t\t)}\n\t\t\t\t{animationNode && (\n\t\t\t\t\t<g>\n\t\t\t\t\t\t<circle\n\t\t\t\t\t\t\tclassName=\"node animation-node\"\n\t\t\t\t\t\t\tr={NODE_RADIUS}\n\t\t\t\t\t\t\tcx={animationNode.x}\n\t\t\t\t\t\t\tcy={animationNode.y}\n\t\t\t\t\t\t></circle>\n\t\t\t\t\t\t<text\n\t\t\t\t\t\t\tx={animationNode.x}\n\t\t\t\t\t\t\ty={animationNode.y}\n\t\t\t\t\t\t\tclassName=\"animation-node node-number\"\n\t\t\t\t\t\t\ttextAnchor=\"middle\"\n\t\t\t\t\t\t\tstroke=\"black\"\n\t\t\t\t\t\t\tstrokeWidth=\"0.5px\"\n\t\t\t\t\t\t\talignmentBaseline=\"middle\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{animationNode.id}\n\t\t\t\t\t\t</text>\n\t\t\t\t\t\t<circle\n\t\t\t\t\t\t\tclassName=\"node original-node\"\n\t\t\t\t\t\t\tr={NODE_RADIUS}\n\t\t\t\t\t\t\tcx={originalNode.x}\n\t\t\t\t\t\t\tcy={originalNode.y}\n\t\t\t\t\t\t></circle>\n\t\t\t\t\t\t<text\n\t\t\t\t\t\t\tx={originalNode.x}\n\t\t\t\t\t\t\ty={originalNode.y}\n\t\t\t\t\t\t\tclassName=\"original-node node-number\"\n\t\t\t\t\t\t\ttextAnchor=\"middle\"\n\t\t\t\t\t\t\tstroke=\"black\"\n\t\t\t\t\t\t\tstrokeWidth=\"0.5px\"\n\t\t\t\t\t\t\talignmentBaseline=\"middle\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{originalNode.id}\n\t\t\t\t\t\t</text>\n\t\t\t\t\t</g>\n\t\t\t\t)}\n\t\t\t</svg>\n\n\t\t\t<Sidebar\n\t\t\t\tdrawGraph={drawGraph}\n\t\t\t\tlockUnlock={toggleDrawGraph}\n\t\t\t\ttoggleDeleteMode={toggleDeleteMode}\n\t\t\t\ttoggleMoveMode={toggleMoveMode}\n\t\t\t\ttoggleWeighted={toggleWeighted}\n\t\t\t\ttoggleDirected={toggleDirected}\n\t\t\t\thandleChangeGraphType={handleChangeGraphType}\n\t\t\t\tisDeleteMode={deleteMode}\n\t\t\t\tisMoveMode={moveMode}\n\t\t\t\tweighted={weighted}\n\t\t\t\tdirected={directed}\n\t\t\t\tclearGraph={clearGraph}\n\t\t\t\ttoggleStartAnimationNode={toggleStartAnimationNode}\n\t\t\t\talgorithmType={algorithmType}\n\t\t\t\tis_animation={animate}\n\t\t\t\tdijkstraPopup={togglePopup}\n\t\t\t\tdijkstraPopupOpen={popupOpen}\n\t\t\t></Sidebar>\n\n\t\t\t{animateDone && (\n\t\t\t\t<button className=\"animation-reset-button\" onClick={handleGraphReset}>\n\t\t\t\t\tReset\n\t\t\t\t</button>\n\t\t\t)}\n\n\t\t\t{popupOpen && (\n\t\t\t\t<DijkstraPopup\n\t\t\t\t\thandleClose={togglePopup}\n\t\t\t\t\ttoggleStartAnimationNode={toggleStartAnimationNode}\n\t\t\t\t></DijkstraPopup>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n","import \"./App.css\";\nimport { Graph } from \"./Graph/Graph\";\n\nfunction App() {\n\treturn <Graph></Graph>;\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}